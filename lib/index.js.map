{"version":3,"sources":["../src/index.js"],"names":["FormatDurationOutputIntervals","generateFormattedDurationFromTimestamp","durationTimestampInput","formatting","positive","Number","durationTimestamp","intervals","interval","length","initVal","remainderDuration","lastInterval","results","outputResult","reduce","acc","selectedIntervalValue","availableIntervalDuration","as","decimalPlaces","notation","precision","subtract","join","generateFormattedTime","selectedFormat","input","inputAsInt","parseInt","momentObj","isValid","format","insertThousandSeparators","value","separator","parts","toString","split","replace","formatNumber","columnType","formattedNumber","units","thousandSeparator","formattingOptions","Math","floor","roundedValue","valueWithSeperators","prefix","postfix","e","columnValue","Error","newFormatting"],"mappings":"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","file":"index.js","sourcesContent":["import { duration, utc } from 'moment';\nimport {\n  format, number, floor, round, abs,\n} from 'mathjs';\nimport {\n  includes, filter, last, intersection, isEmpty,\n} from 'lodash';\n\nconst FormatDurationOutputIntervals = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second'];\nconst generateFormattedDurationFromTimestamp = (durationTimestampInput, formatting) => {\n  const positive = Number(durationTimestampInput) >= 0;\n  const durationTimestamp = abs(Number(durationTimestampInput));\n  const intervals = intersection(\n    FormatDurationOutputIntervals,\n    filter(formatting.interval, interval => includes(FormatDurationOutputIntervals, interval)),\n  );\n  if (intervals.length === 0) {\n    return durationTimestamp;\n  }\n  const initVal = {\n    remainderDuration: duration(durationTimestamp),\n    lastInterval: last(intervals),\n    formatting,\n    results: [],\n  };\n  const outputResult = intervals.reduce((acc, interval) => {\n    let selectedIntervalValue;\n    if (interval === acc.lastInterval) {\n      const availableIntervalDuration = acc.remainderDuration.as(interval);\n      if (acc.formatting.decimalPlaces === -1) {\n        selectedIntervalValue = Number(format(\n          availableIntervalDuration,\n          { notation: 'fixed', precision: 2 },\n        ));\n      } else if (acc.formatting.decimalPlaces === 0) {\n        selectedIntervalValue = round(availableIntervalDuration);\n      } else {\n        selectedIntervalValue = format(availableIntervalDuration, {\n          notation: 'fixed',\n          precision: acc.formatting.decimalPlaces,\n        });\n      }\n    } else {\n      selectedIntervalValue = floor(acc.remainderDuration.as(interval));\n    }\n    return {\n      ...acc,\n      remainderDuration: acc.remainderDuration.subtract(selectedIntervalValue, interval),\n      results: [\n        ...acc.results,\n        `${selectedIntervalValue} ${interval}`,\n      ],\n    };\n  }, initVal);\n  return positive ? outputResult.results.join(' ') : `-(${outputResult.results.join(' ')})`;\n};\nconst generateFormattedTime = (selectedFormat, input) => {\n  const inputAsInt = parseInt(input, 10);\n  const momentObj = utc(inputAsInt, 'x');\n  if (!momentObj.isValid()) {\n    return input;\n  }\n  if (selectedFormat === '12HR') {\n    return momentObj.format('hh:mm:ss a');\n  }\n  return momentObj.format('HH:mm:ss');\n};\nconst insertThousandSeparators = (value, separator) => {\n  const parts = value.toString().split('.');\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, separator);\n  return parts.join('.');\n};\nconst formatNumber = (value, formatting, columnType) => {\n  let formattedNumber;\n  const {\n    units, decimalPlaces, thousandSeparator, interval, selectedFormat,\n  } = formatting;\n  switch (columnType) {\n    case 'FORMULA_DURATION':\n      formattedNumber = generateFormattedDurationFromTimestamp(value, formatting);\n      break;\n    case 'DURATION':\n      const formattingOptions = { notation: 'fixed', precision: value - Math.floor(value) !== 0 ? 2 : 0 };\n      formattedNumber = `${format(number(value), formattingOptions)} ${interval[0]}${value > 1 ? 's' : ''}`;\n      break;\n    case 'TIME':\n      formattedNumber = generateFormattedTime(selectedFormat, value);\n      break;\n    default:\n      if (value !== 'ERROR') {\n        try {\n          const roundedValue = decimalPlaces > -1 ? format(number(value), {\n            notation: 'fixed',\n            precision: decimalPlaces,\n          }) : value;\n          const valueWithSeperators = isEmpty(thousandSeparator)\n            ? roundedValue\n            : insertThousandSeparators(roundedValue, thousandSeparator);\n          formattedNumber = `${units.prefix}${valueWithSeperators}${units.postfix}`;\n        } catch (e) {\n          formattedNumber = value;\n        }\n      }\n      break;\n  }\n  return formattedNumber;\n};\nexport default (value, { columnType, formatting }, formattingOptions = {}) => {\n  let columnValue;\n  if (value === '') {\n    columnValue = '';\n  } else if (value === 'ERROR') {\n    columnValue = 'ERROR';\n  } else {\n    switch (columnType) {\n      case 'DATE':\n        columnValue = utc(parseInt(value, 0)).format('ll');\n        break;\n      case 'DATETIME':\n        columnValue = utc(parseInt(value, 0)).format('MMM D, YYYY HH:mm:ss');\n        break;\n      case 'FORMULA_DATETIME':\n        columnValue = utc(parseInt(value, 0)).format('MMM D, YYYY HH:mm:ss');\n        break;\n      case 'SOURCE':\n        throw new Error('Cannot resolve columnType: SOURCE formatting');\n      case 'AGGREGATION_SOURCE':\n        columnValue = value;\n        break;\n      default:\n        const newFormatting = { ...formatting, ...formattingOptions };\n        columnValue = formatNumber(value, newFormatting, columnType);\n        break;\n    }\n  }\n  return columnValue;\n};\n"]}